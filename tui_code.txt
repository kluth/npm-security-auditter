

Here's the full TUI implementation using Bubble Tea:

## internal/tui/model.go

```go
package tui

import (
	"fmt"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/list"
	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
)

// Screen represents which screen is currently active.
type Screen int

const (
	ScreenMain Screen = iota
	ScreenAuditPackage
	ScreenAuditProject
	ScreenAuditNodeModules
	ScreenSettings
	ScreenThreatIntel
	ScreenResults
	ScreenResultDetail
	ScreenRunning
	ScreenSaveReport
)

// MenuItem is an item in a list.
type MenuItem struct {
	title string
	desc  string
}

func (m MenuItem) Title() string       { return m.title }
func (m MenuItem) Description() string { return m.desc }
func (m MenuItem) FilterValue() string { return m.title }

// Finding holds a single audit finding for display.
type Finding struct {
	Analyzer string
	Severity string
	Title    string
	Detail   string
	File     string
	Line     int
}

func (f Finding) FilterValue() string { return f.Title }
func (f Finding) Title() string {
	return fmt.Sprintf("[%s] %s", f.Severity, f.Title)
}
func (f Finding) Description() string {
	if f.File != "" {
		return fmt.Sprintf("%s — %s:%d", f.Analyzer, f.File, f.Line)
	}
	return f.Analyzer
}

// AuditResult holds the full result of an audit run.
type AuditResult struct {
	PackageName string
	RiskScore   float64
	Findings    []Finding
	Duration    time.Duration
	Error       error
}

// SettingsField identifies which setting is being edited.
type SettingsField int

const (
	FieldRegistry SettingsField = iota
	FieldTimeout
	FieldSeverity
	FieldLanguage
	FieldCount
)

// Model is the top-level Bubble Tea model.
type Model struct {
	screen       Screen
	prevScreen   Screen
	width        int
	height       int
	quitting     bool
	err          error

	// Main menu
	mainMenu list.Model

	// Text inputs (reused across screens)
	textInput textinput.Model

	// Settings
	settingsFields  [FieldCount]textinput.Model
	settingsFocus   SettingsField
	settingsValues  SettingsConfig

	// Threat intel
	threatInput textinput.Model

	// Running state
	spinner  spinner.Model
	runMsg   string
	auditFn  func() tea.Msg

	// Results
	results       *AuditResult
	findingsList  list.Model
	selectedIdx   int
	detailView    viewport.Model
	saveInput     textinput.Model

	// Report save path
	reportPath string
}

// SettingsConfig holds persisted settings values.
type SettingsConfig struct {
	Registry string
	Timeout  string
	Severity string
	Language string
}

// Messages
type auditCompleteMsg struct{ result *AuditResult }
type auditErrorMsg struct{ err error }
type reportSavedMsg struct{ path string }
type reportSaveErrorMsg struct{ err error }
type threatUpdateMsg struct{ msg string }
type threatErrorMsg struct{ err error }

func NewModel() Model {
	// Main menu
	items := []list.Item{
		MenuItem{title: "Audit Package", desc: "Scan a single npm package by name"},
		MenuItem{title: "Audit Project", desc: "Scan a project directory's package.json"},
		MenuItem{title: "Audit node_modules", desc: "Scan installed node_modules directory"},
		MenuItem{title: "Settings", desc: "Configure registry, timeout, severity, language"},
		MenuItem{title: "Threat Intelligence", desc: "Update threat intelligence sources"},
		MenuItem{title: "Results", desc: "View last audit results and findings"},
	}
	mainMenu := list.New(items, list.NewDefaultDelegate(), 0, 0)
	mainMenu.Title = "npm-security-auditter"
	mainMenu.SetShowStatusBar(false)
	mainMenu.SetFilteringEnabled(false)
	mainMenu.DisableQuitKeybindings()

	// Spinner
	sp := spinner.New()
	sp.Spinner = spinner.Dot
	sp.Style = SpinnerStyle

	// Text input for package name
	ti := textinput.New()
	ti.Placeholder = "e.g. lodash@4.17.21"
	ti.CharLimit = 256
	ti.Width = 50

	// Settings fields
	var sf [FieldCount]textinput.Model
	placeholders := [FieldCount]string{
		"https://registry.npmjs.org",
		"30",
		"low",
		"en",
	}
	labels := [FieldCount]string{
		"Registry URL",
		"Timeout (seconds)",
		"Min Severity (low/medium/high/critical)",
		"Language",
	}
	defaults := SettingsConfig{
		Registry: "https://registry.npmjs.org",
		Timeout:  "30",
		Severity: "low",
		Language: "en",
	}
	vals := [FieldCount]string{defaults.Registry, defaults.Timeout, defaults.Severity, defaults.Language}
	for i := 0; i < int(FieldCount); i++ {
		sf[i] = textinput.New()
		sf[i].Placeholder = placeholders[i]
		sf[i].Prompt = labels[i] + ": "
		sf[i].CharLimit = 256
		sf[i].Width = 50
		sf[i].SetValue(vals[i])
	}
	sf[0].Focus()

	// Threat input
	threatIn := textinput.New()
	threatIn.Placeholder = "e.g. https://threat-feed.example.com/feed.json"
	threatIn.CharLimit = 512
	threatIn.Width = 60

	// Save input
	saveIn := textinput.New()
	saveIn.Placeholder = "report.json"
	saveIn.CharLimit = 256
	saveIn.Width = 50

	// Findings list (empty initially)
	fl := list.New(nil, list.NewDefaultDelegate(), 0, 0)
	fl.Title = "Findings"
	fl.SetShowStatusBar(true)
	fl.SetFilteringEnabled(true)
	fl.DisableQuitKeybindings()

	// Detail viewport
	dv := viewport.New(0, 0)

	return Model{
		screen:         ScreenMain,
		mainMenu:       mainMenu,
		textInput:      ti,
		settingsFields: sf,
		settingsFocus:  FieldRegistry,
		settingsValues: defaults,
		threatInput:    threatIn,
		spinner:        sp,
		findingsList:   fl,
		detailView:     dv,
		saveInput:      saveIn,
	}
}

func (m Model) Init() tea.Cmd {
	return tea.Batch(m.spinner.Tick, tea.EnterAltScreen)
}

// helpers

func clamp(v, lo, hi int) int {
	if v < lo {
		return lo
	}
	if v > hi {
		return hi
	}
	return v
}

func severityColor(sev string) string {
	switch strings.ToLower(sev) {
	case "critical":
		return "\033[91m" // bright red
	case "high":
		return "\033[31m" // red
	case "medium":
		return "\033[33m" // yellow
	case "low":
		return "\033[36m" // cyan
	default:
		return "\033[37m" // white
	}
}

func riskScoreBar(score float64, width int) string {
	filled := int(score / 100.0 * float64(width))
	filled = clamp(filled, 0, width)
	empty := width - filled
	bar := strings.Repeat("█", filled) + strings.Repeat("░", empty)
	return bar
}
```

## internal/tui/styles.go

```go
package tui

import "github.com/charmbracelet/lipgloss"

var (
	// Colors
	ColorPrimary   = lipgloss.Color("#7C3AED")
	ColorSecondary = lipgloss.Color("#06B6D4")
	ColorDanger    = lipgloss.Color("#EF4444")
	ColorWarning   = lipgloss.Color("#F59E0B")
	ColorSuccess   = lipgloss.Color("#10B981")
	ColorMuted     = lipgloss.Color("#6B7280")
	ColorBg        = lipgloss.Color("#1E1E2E")
	ColorFg        = lipgloss.Color("#CDD6F4")
	ColorAccent    = lipgloss.Color("#F5C2E7")

	// Base styles
	AppStyle = lipgloss.NewStyle().
			Background(ColorBg)

	TitleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(ColorAccent).
			Background(lipgloss.Color("#313244")).
			Padding(0, 2).
			MarginBottom(1)

	SubtitleStyle = lipgloss.NewStyle().
			Foreground(ColorMuted).
			Italic(true)

	// Status bar
	StatusBarStyle = lipgloss.NewStyle().
			Foreground(ColorFg).
			Background(lipgloss.Color("#313244")).
			Padding(0, 1)

	StatusKeyStyle = lipgloss.NewStyle().
			Foreground(ColorPrimary).
			Bold(true)

	// Input styles
	InputLabelStyle = lipgloss.NewStyle().
			Foreground(ColorSecondary).
			Bold(true).
			MarginRight(1)

	InputStyle = lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(ColorPrimary).
			Padding(0, 1).
			MarginTop(1)

	// Card / Box
	BoxStyle = lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(ColorPrimary).
			Padding(1, 2).
			MarginTop(1)

	// Severity styles
	SevCriticalStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#FFFFFF")).
				Background(ColorDanger).
				Bold(true).
				Padding(0, 1)

	SevHighStyle = lipgloss.NewStyle().
			Foreground(ColorDanger).
			Bold(true)

	SevMediumStyle = lipgloss.NewStyle().
			Foreground(ColorWarning).
			Bold(true)

	SevLowStyle = lipgloss.NewStyle().
			Foreground(ColorSecondary)

	// Risk score
	RiskBarHighStyle = lipgloss.NewStyle().
				Foreground(ColorDanger)

	RiskBarMedStyle = lipgloss.NewStyle().
			Foreground(ColorWarning)

	RiskBarLowStyle = lipgloss.NewStyle().
			Foreground(ColorSuccess)

	// Spinner
	SpinnerStyle = lipgloss.NewStyle().
			Foreground(ColorPrimary)

	// Help / footer
	HelpStyle = lipgloss.NewStyle().
			Foreground(ColorMuted).
			MarginTop(1)

	// Detail view
	DetailHeaderStyle = lipgloss.NewStyle().
				Bold(true).
				Foreground(ColorAccent).
				MarginBottom(1)

	DetailLabelStyle = lipgloss.NewStyle().
				Foreground(ColorSecondary).
				Bold(true)

	DetailValueStyle = lipgloss.NewStyle().
				Foreground(ColorFg)

	// Tab-like active field indicator
	ActiveFieldStyle = lipgloss.NewStyle().
				Border(lipgloss.RoundedBorder()).
				BorderForeground(ColorPrimary).
				Padding(0, 1)

	InactiveFieldStyle = lipgloss.NewStyle().
				Border(lipgloss.RoundedBorder()).
				BorderForeground(ColorMuted).
				Padding(0, 1)

	// Success / Error messages
	SuccessStyle = lipgloss.NewStyle().
			Foreground(ColorSuccess).
			Bold(true)

	ErrorStyle = lipgloss.NewStyle().
			Foreground(ColorDanger).
			Bold(true)
)

func SeverityStyle(sev string) lipgloss.Style {
	switch sev {
	case "critical":
		return SevCriticalStyle
	case "high":
		return SevHighStyle
	case "medium":
		return SevMediumStyle
	default:
		return SevLowStyle
	}
}

func RiskBarStyle(score float64) lipgloss.Style {
	switch {
	case score >= 70:
		return RiskBarHighStyle
	case score >= 40:
		return RiskBarMedStyle
	default:
		return RiskBarLowStyle
	}
}
```

## internal/tui/update.go

```go
package tui

import (
	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
)

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.mainMenu.SetSize(msg.Width, msg.Height-4)
		m.findingsList.SetSize(msg.Width, msg.Height-8)
		m.detailView.Width = msg.Width - 4
		m.detailView.Height = msg.Height - 8
		return m, nil

	case tea.KeyMsg:
		// Global quit
		if msg.String() == "ctrl+c" {
			m.quitting = true
			return m, tea.Quit
		}

	case auditCompleteMsg:
		m.results = msg.result
		m.screen = ScreenResults
		m.populateFindings()
		return m, nil

	case auditErrorMsg:
		m.err = msg.err
		m.screen = ScreenResults
		m.results = &AuditResult{Error: msg.err}
		return m, nil

	case reportSavedMsg:
		m.reportPath = msg.path
		return m, nil

	case reportSaveErrorMsg:
		m.err = msg.err
		return m, nil

	case threatUpdateMsg:
		m.screen = ScreenMain
		return m, nil

	case threatErrorMsg:
		m.err = msg.err
		m.screen = ScreenMain
		return m, nil
	}

	switch m.screen {
	case ScreenMain:
		return m.updateMain(msg)
	case ScreenAuditPackage:
		return m.updateAuditPackage(msg)
	case ScreenAuditProject:
		return m.updateAuditProject(msg)
	case ScreenAuditNodeModules:
		return m.updateAuditNodeModules(msg)
	case ScreenSettings:
		return m.updateSettings(msg)
	case ScreenThreatIntel:
		return m.updateThreatIntel(msg)
	case ScreenResults:
		return m.updateResults(msg)
	case ScreenResultDetail:
		return m.updateResultDetail(msg)
	case ScreenRunning:
		return m.updateRunning(msg)
	case ScreenSaveReport:
		return m.updateSaveReport(msg)
	}
	return m, nil
}

func (m Model) updateMain(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "q", "esc":
			m.quitting = true
			return m, tea.Quit
		case "enter":
			idx := m.mainMenu.Index()
			switch idx {
			case 0:
				m.screen = ScreenAuditPackage
				m.textInput.SetValue("")
				m.textInput.Placeholder = "e.g. lodash@4.17.21"
				m.textInput.Focus()
				return m, m.textInput.Cursor.BlinkCmd()
			case 1:
				m.screen = ScreenAuditProject
				m.textInput.SetValue("")
				m.textInput.Placeholder = "e.g. /path/to/project"
				m.textInput.Focus()
				return m, m.textInput.Cursor.BlinkCmd()
			case 2:
				m.screen = ScreenAuditNodeModules
				m.textInput.SetValue("")
				m.textInput.Placeholder = "e.g. /path/to/node_modules"
				m.textInput.Focus()
				return m, m.textInput.Cursor.BlinkCmd()
			case 3:
				m.screen = ScreenSettings
				m.settingsFocus = FieldRegistry
				for i := range m.settingsFields {
					m.settingsFields[i].Blur()
				}
				m.settingsFields[0].Focus()
				return m, m.settingsFields[0].Cursor.BlinkCmd()
			case 4:
				m.screen = ScreenThreatIntel
				m.threatInput.SetValue("")
				m.threatInput.Focus()
				return m, m.threatInput.Cursor.BlinkCmd()
			case 5:
				if m.results != nil {
					m.screen = ScreenResults
					m.populateFindings()
				}
				return m, nil
			}
		}
	}
	var cmd tea.Cmd
	m.mainMenu, cmd = m.mainMenu.Update(msg)
	return m, cmd
}

func (m Model) updateAuditPackage(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc":
			m.screen = ScreenMain
			return m, nil
		case "enter":
			val := m.textInput.Value()
			if val == "" {
				return m, nil
			}
			m.runMsg = "Auditing package: " + val
			m.screen = ScreenRunning
			m.auditFn = func() tea.Msg {
				return runPackageAudit(val, m.settingsValues)
			}
			return m, tea.Batch(m.spinner.Tick, func() tea.Msg { return m.auditFn() })
		}
	}
	var cmd tea.Cmd
	m.textInput, cmd = m.textInput.Update(msg)
	return m, cmd
}

func (m Model) updateAuditProject(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc":
			m.screen = ScreenMain
			return m, nil
		case "enter":
			val := m.textInput.Value()
			if val == "" {
				return m, nil
			}
			m.runMsg = "Auditing project: " + val
			m.screen = ScreenRunning
			m.auditFn = func() tea.Msg {
				return runProjectAudit(val, m.settingsValues)
			}
			return m, tea.Batch(m.spinner.Tick, func() tea.Msg { return m.auditFn() })
		}
	}
	var cmd tea.Cmd
	m.textInput, cmd = m.textInput.Update(msg)
	return m, cmd
}

func (m Model) updateAuditNodeModules(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc":
			m.screen = ScreenMain
			return m, nil
		case "enter":
			val := m.textInput.Value()
			if val == "" {
				return m, nil
			}
			m.runMsg = "Auditing node_modules: " + val
			m.screen = ScreenRunning
			m.auditFn = func() tea.Msg {
				return runNodeModulesAudit(val, m.settingsValues)
			}
			return m, tea.Batch(m.spinner.Tick, func() tea.Msg { return m.auditFn() })
		}
	}
	var cmd tea.Cmd
	m.textInput, cmd = m.textInput.Update(msg)
	return m, cmd
}

func (m Model) updateSettings(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc":
			// Save values back
			m.settingsValues.Registry = m.settingsFields[FieldRegistry].Value()
			m.settingsValues.Timeout = m.settingsFields[FieldTimeout].Value()
			m.settingsValues.Severity = m.settingsFields[FieldSeverity].Value()
			m.settingsValues.Language = m.settingsFields[FieldLanguage].Value()
			m.screen = ScreenMain
			return m, nil
		case "tab", "down":
			m.settingsFields[m.settingsFocus].Blur()
			m.settingsFocus = (m.settingsFocus + 1) % FieldCount
			m.settingsFields[m.settingsFocus].Focus()
			return m, m.settingsFields[m.settingsFocus].Cursor.BlinkCmd()
		case "shift+tab", "up":
			m.settingsFields[m.settingsFocus].Blur()
			m.settingsFocus = (m.settingsFocus - 1 + FieldCount) % FieldCount
			m.settingsFields[m.settingsFocus].Focus()
			return m, m.settingsFields[m.settingsFocus].Cursor.BlinkCmd()
		}
	}
	var cmd tea.Cmd
	m.settingsFields[m.settingsFocus], cmd = m.settingsFields[m.settingsFocus].Update(msg)
	return m, cmd
}

func (m Model) updateThreatIntel(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc":
			m.screen = ScreenMain
			return m, nil
		case "enter":
			val := m.threatInput.Value()
			if val == "" {
				return m, nil
			}
			m.runMsg = "Updating threat intelligence..."
			m.screen = ScreenRunning
			m.auditFn = func() tea.Msg {
				return runThreatUpdate(val)
			}
			return m, tea.Batch(m.spinner.Tick, func() tea.Msg { return m.auditFn() })
		}
	}
	var cmd tea.Cmd
	m.threatInput, cmd = m.threatInput.Update(msg)
	return m, cmd
}

func (m Model) updateResults(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc":
			m.screen = ScreenMain
			return m, nil
		case "enter":
			if m.results != nil && len(m.results.Findings) > 0 {
				m.selectedIdx = m.findingsList.Index()
				m.screen = ScreenResultDetail
				m.detailView.SetContent(m.renderFindingDetail(m.selectedIdx))
				m.detailView.GotoTop()
				return m, nil
			}
		case "s":
			m.screen = ScreenSaveReport
			m.saveInput.SetValue("")
			m.saveInput.Focus()
			return m, m.saveInput.Cursor.BlinkCmd()
		}
	}
	var cmd tea.Cmd
	m.findingsList, cmd = m.findingsList.Update(msg)
	return m, cmd
}

func (m Model) updateResultDetail(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc", "q":
			m.screen = ScreenResults
			return m, nil
		case "left", "h":
			if m.selectedIdx > 0 {
				m.selectedIdx--
				m.detailView.SetContent(m.renderFindingDetail(m.selectedIdx))
				m.detailView.GotoTop()
			}
			return m, nil
		case "right", "l":
			if m.results != nil && m.selectedIdx < len(m.results.Findings)-1 {
				m.selectedIdx++
				m.detailView.SetContent(m.renderFindingDetail(m.selectedIdx))
				m.detailView.GotoTop()
			}
			return m, nil
		}
	}
	var cmd tea.Cmd
	m.detailView, cmd = m.detailView.Update(msg)
	return m, cmd
}

func (m Model) updateRunning(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	m.spinner, cmd = m.spinner.Update(msg)
	return m, cmd
}

func (m Model) updateSaveReport(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc":
			m.screen = ScreenResults
			return m, nil
		case "enter":
			path := m.saveInput.Value()
			if path == "" {
				path = "report.json"
			}
			m.screen = ScreenResults
			return m, func() tea.Msg {
				return saveReport(m.results, path)
			}
		}
	}
	var cmd tea.Cmd
	m.saveInput, cmd = m.saveInput.Update(msg)
	return m, cmd
}

func (m *Model) populateFindings() {
	if m.results == nil {
		return
	}
	items := make([]list.Item, len(m.results.Findings))
	for i, f := range m.results.Findings {
		items[i] = f
	}
	m.findingsList.SetItems(items)
}
```

## internal/tui/view.go

```go
package tui

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/lipgloss"
)

func (m Model) View() string {
	if m.quitting {
		return ""
	}

	var content string
	switch m.screen {
	case ScreenMain:
		content = m.viewMain()
	case ScreenAuditPackage:
		content = m.viewAuditPackage()
	case ScreenAuditProject:
		content = m.viewAuditProject()
	case ScreenAuditNodeModules:
		content = m.viewAuditNodeModules()
	case ScreenSettings:
		content = m.viewSettings()
	case ScreenThreatIntel:
		content = m.viewThreatIntel()
	case ScreenResults:
		content = m.viewResults()
	case ScreenResultDetail:
		content = m.viewResultDetail()
	case ScreenRunning:
		content = m.viewRunning()
	case ScreenSaveReport:
		content = m.viewSaveReport()
	}

	// Compose with status bar
	statusBar := m.viewStatusBar()
	return lipgloss.JoinVertical(lipgloss.Left, content, statusBar)
}

func (m Model) viewStatusBar() string {
	var keys string
	switch m.screen {
	case ScreenMain:
		keys = "↑/↓ navigate • enter select • q quit"
	case ScreenAuditPackage, ScreenAuditProject, ScreenAuditNodeModules:
		keys = "enter submit • esc back"
	case ScreenSettings:
		keys = "tab/↓ next field • shift+tab/↑ prev • esc save & back"
	case ScreenThreatIntel:
		keys = "enter update • esc back"
	case ScreenResults:
		keys = "↑/↓ navigate • enter detail • s save report • esc back"
	case ScreenResultDetail:
		keys = "←/→ prev/next finding • ↑/↓ scroll • esc back"
	case ScreenRunning:
		keys = "please wait..."
	case ScreenSaveReport:
		keys = "enter save • esc cancel"
	}
	bar := StatusBarStyle.Width(m.width).Render(keys)
	return bar
}

func (m Model) viewMain() string {
	return m.mainMenu.View()
}

func (m Model) viewAuditPackage() string {
	var b strings.Builder
	b.WriteString(TitleStyle.Render("Audit Package"))
	b.WriteString("\n\n")
	b.WriteString(InputLabelStyle.Render("Package name (optionally with @version):"))
	b.WriteString("\n")
	b.WriteString(InputStyle.Width(m.width - 6).Render(m.textInput.View()))
	b.WriteString("\n\n")
	b.WriteString(HelpStyle.Render("Examples: lodash, express@4.18.2, @babel/core"))
	return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
		lipgloss.NewStyle().Padding(1, 2).Render(b.String()))
}

func (m Model) viewAuditProject() string {
	var b strings.Builder
	b.WriteString(TitleStyle.Render("Audit Project"))
	b.WriteString("\n\n")
	b.WriteString(InputLabelStyle.Render("Project directory path:"))
	b.WriteString("\n")
	b.WriteString(InputStyle.Width(m.width - 6).Render(m.textInput.View()))
	b.WriteString("\n\n")
	b.WriteString(HelpStyle.Render("Enter the path to a directory containing package.json"))
	return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
		lipgloss.NewStyle().Padding(1, 2).Render(b.String()))
}

func (m Model) viewAuditNodeModules() string {
	var b strings.Builder
	b.WriteString(TitleStyle.Render("Audit node_modules"))
	b.WriteString("\n\n")
	b.WriteString(InputLabelStyle.Render("Path to node_modules directory:"))
	b.WriteString("\n")
	b.WriteString(InputStyle.Width(m.width - 6).Render(m.textInput.View()))
	b.WriteString("\n\n")
	b.WriteString(HelpStyle.Render("Enter the path to the node_modules directory to scan"))
	return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
		lipgloss.NewStyle().Padding(1, 2).Render(b.String()))
}

func (m Model) viewSettings() string {
	var b strings.Builder
	b.WriteString(TitleStyle.Render("Settings"))
	b.WriteString("\n\n")

	labels := [FieldCount]string{"Registry URL", "Timeout (seconds)", "Min Severity", "Language"}
	for i := 0; i < int(FieldCount); i++ {
		style := InactiveFieldStyle
		if SettingsField(i) == m.settingsFocus {
			style = ActiveFieldStyle
		}
		b.WriteString(InputLabelStyle.Render(labels[i]))
		b.WriteString("\n")
		b.WriteString(style.Width(m.width - 8).Render(m.settingsFields[i].View()))
		b.WriteString("\n\n")
	}

	return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
		lipgloss.NewStyle().Padding(1, 2).Render(b.String()))
}

func (m Model) viewThreatIntel() string {
	var b strings.Builder
	b.WriteString(TitleStyle.Render("Threat Intelligence"))
	b.WriteString("\n\n")
	b.WriteString(InputLabelStyle.Render("Threat feed source URL:"))
	b.WriteString("\n")
	b.WriteString(InputStyle.Width(m.width - 6).Render(m.threatInput.View()))
	b.WriteString("\n\n")
	b.WriteString(HelpStyle.Render("Enter a threat intelligence feed URL to update local threat data"))
	return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
		lipgloss.NewStyle().Padding(1, 2).Render(b.String()))
}

func (m Model) viewResults() string {
	if m.results == nil {
		content := BoxStyle.Width(m.width - 6).Render(
			SubtitleStyle.Render("No audit results yet. Run an audit first."))
		return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
			lipgloss.NewStyle().Padding(1, 2).Render(
				TitleStyle.Render("Results")+"\n"+content))
	}

	if m.results.Error != nil {
		content := BoxStyle.Width(m.width - 6).Render(
			ErrorStyle.Render("Error: "+m.results.Error.Error()))
		return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
			lipgloss.NewStyle().Padding(1, 2).Render(
				TitleStyle.Render("Results")+"\n"+content))
	}

	var b strings.Builder
	b.WriteString(TitleStyle.Render("Audit Results"))
	b.WriteString("\n\n")

	// Summary card
	summary := m.viewResultsSummary()
	b.WriteString(BoxStyle.Width(m.width - 6).Render(summary))
	b.WriteString("\n\n")

	// Report saved indicator
	if m.reportPath != "" {
		b.WriteString(SuccessStyle.Render("Report saved to: "+m.reportPath))
		b.WriteString("\n\n")
	}

	// Findings list
	b.WriteString(m.findingsList.View())

	return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
		lipgloss.NewStyle().Padding(1, 2).Render(b.String()))
}

func (m Model) viewResultsSummary() string {
	r := m.results
	var b strings.Builder

	// Package + duration
	if r.PackageName != "" {
		b.WriteString(DetailLabelStyle.Render("Package: "))
		b.WriteString(DetailValueStyle.Render(r.PackageName))
		b.WriteString("\n")
	}
	b.WriteString(DetailLabelStyle.Render("Duration: "))
	b.WriteString(DetailValueStyle.Render(r.Duration.String()))
	b.WriteString("\n")

	// Risk score bar
	b.WriteString(DetailLabelStyle.Render("Risk Score: "))
	scoreStr := fmt.Sprintf("%.0f/100", r.RiskScore)
	barWidth := 30
	bar := riskScoreBar(r.RiskScore, barWidth)
	b.WriteString(RiskBarStyle(r.RiskScore).Render(bar))
	b.WriteString(" ")
	b.WriteString(DetailValueStyle.Render(scoreStr))
	b.WriteString("\n")

	// Severity breakdown
	counts := map[string]int{"critical": 0, "high": 0, "medium": 0, "low": 0}
	for _, f := range r.Findings {
		counts[strings.ToLower(f.Severity)]++
	}
	b.WriteString(DetailLabelStyle.Render("Findings: "))
	b.WriteString(fmt.Sprintf("%d total", len(r.Findings)))
	b.WriteString("  ")
	b.WriteString(SevCriticalStyle.Render(fmt.Sprintf(" %d critical ", counts["critical"])))
	b.WriteString(" ")
	b.WriteString(SevHighStyle.Render(fmt.Sprintf("%d high", counts["high"])))
	b.WriteString(" ")
	b.WriteString(SevMediumStyle.Render(fmt.Sprintf("%d medium", counts["medium"])))
	b.WriteString(" ")
	b.WriteString(SevLowStyle.Render(fmt.Sprintf("%d low", counts["low"])))

	return b.String()
}

func (m Model) viewResultDetail() string {
	if m.results == nil || len(m.results.Findings) == 0 {
		return ""
	}

	var b strings.Builder
	f := m.results.Findings[m.selectedIdx]
	nav := fmt.Sprintf("Finding %d of %d", m.selectedIdx+1, len(m.results.Findings))
	b.WriteString(TitleStyle.Render("Finding Detail"))
	b.WriteString("  ")
	b.WriteString(SubtitleStyle.Render(nav))
	b.WriteString("\n\n")

	detailBox := BoxStyle.Width(m.width - 6).Render(m.detailView.View())
	b.WriteString(detailBox)

	_ = f // used in renderFindingDetail

	return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
		lipgloss.NewStyle().Padding(1, 2).Render(b.String()))
}

func (m Model) renderFindingDetail(idx int) string {
	if m.results == nil || idx >= len(m.results.Findings) {
		return ""
	}
	f := m.results.Findings[idx]

	var b strings.Builder
	b.WriteString(DetailLabelStyle.Render("Title:     "))
	b.WriteString(DetailValueStyle.Render(f.Title))
	b.WriteString("\n\n")

	b.WriteString(DetailLabelStyle.Render("Severity:  "))
	b.WriteString(SeverityStyle(strings.ToLower(f.Severity)).Render(f.Severity))
	b.WriteString("\n\n")

	b.WriteString(DetailLabelStyle.Render("Analyzer:  "))
	b.WriteString(DetailValueStyle.Render(f.Analyzer))
	b.WriteString("\n\n")

	if f.File != "" {
		b.WriteString(DetailLabelStyle.Render("Location:  "))
		loc := f.File
		if f.Line > 0 {
			loc = fmt.Sprintf("%s:%d", f.File, f.Line)
		}
		b.WriteString(DetailValueStyle.Render(loc))
		b.WriteString("\n\n")
	}

	b.WriteString(DetailLabelStyle.Render("Details:"))
	b.WriteString("\n")
	b.WriteString(DetailValueStyle.Render(f.Detail))

	return b.String()
}

func (m Model) viewRunning() string {
	var b strings.Builder
	b.WriteString(TitleStyle.Render("Running"))
	b.WriteString("\n\n")

	spinnerBox := BoxStyle.Width(m.width - 6).Render(
		fmt.Sprintf("%s %s", m.spinner.View(), m.runMsg))
	b.WriteString(spinnerBox)

	return lipgloss.Place(m.width, m.height-2, lipgloss.Center, lipgloss.Center,
		b.String())
}

func (m Model) viewSaveReport() string {
	var b strings.Builder
	b.WriteString(TitleStyle.Render("Save Report"))
	b.WriteString("\n\n")
	b.WriteString(InputLabelStyle.Render("Output file path:"))
	b.WriteString("\n")
	b.WriteString(InputStyle.Width(m.width - 6).Render(m.saveInput.View()))
	b.WriteString("\n\n")
	b.WriteString(HelpStyle.Render("Default: report.json. Supports .json and .txt extensions."))

	return lipgloss.Place(m.width, m.height-2, lipgloss.Left, lipgloss.Top,
		lipgloss.NewStyle().Padding(1, 2).Render(b.String()))
}
```

## internal/tui/commands.go

This file contains the actual audit execution logic that bridges TUI to the auditter core.

```go
package tui

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"

	"github.com/matiasbarram/npm-security-auditter/internal/analyzer"
	"github.com/matiasbarram/npm-security-auditter/internal/project"
	"github.com/matiasbarram/npm-security-auditter/internal/registry"
	"github.com/matiasbarram/npm-security-auditter/internal/reputation"
)

func buildClient(cfg SettingsConfig) *registry.Client {
	timeout := 30
	if v, err := strconv.Atoi(cfg.Timeout); err == nil && v > 0 {
		timeout = v
	}
	reg := cfg.Registry
	if reg == "" {
		reg = "https://registry.npmjs.org"
	}
	return registry.NewClient(reg, time.Duration(timeout)*time.Second)
}

func buildAnalyzers(client *registry.Client) []analyzer.Analyzer {
	return analyzer.DefaultAnalyzers(client)
}

func convertFindings(afs []analyzer.Finding) []Finding {
	out := make([]Finding, len(afs))
	for i, f := range afs {
		out[i] = Finding{
			Analyzer: f.Analyzer,
			Severity: f.Severity,
			Title:    f.Title,
			Detail:   f.Detail,
			File:     f.File,
			Line:     f.Line,
		}
	}
	return out
}

func runPackageAudit(nameVersion string, cfg SettingsConfig) tea.Msg {
	start := time.Now()
	client := buildClient(cfg)

	// Parse name@version
	name := nameVersion
	version := "latest"
	if idx := strings.LastIndex(nameVersion, "@"); idx > 0 {
		name = nameVersion[:idx]
		version = nameVersion[idx+1:]
	}

	ctx := context.Background()

	meta, err := client.GetPackageMetadata(ctx, name)
	if err != nil {
		return auditErrorMsg{err: fmt.Errorf("fetching metadata for %s: %w", name, err)}
	}

	ver, ok := meta.Versions[version]
	if !ok {
		// Try "latest" tag
		if version == "latest" {
			if tag, exists := meta.DistTags["latest"]; exists {
				ver, ok = meta.Versions[tag]
			}
		}
		if !ok {
			return auditErrorMsg{err: fmt.Errorf("version %s not found for %s", version, name)}
		}
	}

	analyzers := buildAnalyzers(client)
	var allFindings []analyzer.Finding
	for _, a := range analyzers {
		findings, aErr := a.Analyze(ctx, meta, &ver)
		if aErr != nil {
			continue
		}
		allFindings = append(allFindings, findings...)
	}

	score := reputation.CalculateRiskScore(allFindings)

	return auditCompleteMsg{result: &AuditResult{
		PackageName: nameVersion,
		RiskScore:   score,
		Findings:    convertFindings(allFindings),
		Duration:    time.Since(start),
	}}
}

func runProjectAudit(path string, cfg SettingsConfig) tea.Msg {
	start := time.Now()
	client := buildClient(cfg)
	ctx := context.Background()

	deps, err := project.ParsePackageJSON(path)
	if err != nil {
		return auditErrorMsg{err: fmt.Errorf("parsing project at %s: %w", path, err)}
	}

	analyzers := buildAnalyzers(client)
	var allFindings []analyzer.Finding

	for _, dep := range deps {
		meta, mErr := client.GetPackageMetadata(ctx, dep.Name)
		if mErr != nil {
			continue
		}
		ver, ok := meta.Versions[dep.Version]
		if !ok {
			if tag, exists := meta.DistTags["latest"]; exists {
				ver, ok = meta.Versions[tag]
			}
		}
		if !ok {
			continue
		}
		for _, a := range analyzers {
			findings, aErr := a.Analyze(ctx, meta, &ver)
			if aErr != nil {
				continue
			}
			allFindings = append(allFindings, findings...)
		}
	}

	score := reputation.CalculateRiskScore(allFindings)

	return auditCompleteMsg{result: &AuditResult{
		PackageName: path,
		RiskScore:   score,
		Findings:    convertFindings(allFindings),
		Duration:    time.Since(start),
	}}
}

func runNodeModulesAudit(path string, cfg SettingsConfig) tea.Msg {
	start := time.Now()
	client := buildClient(cfg)
	ctx := context.Background()

	deps, err := project.ScanNodeModules(path)
	if err != nil {
		return auditErrorMsg{err: fmt.Errorf("scanning node_modules at %s: %w", path, err)}
	}

	analyzers := buildAnalyzers(client)
	var allFindings []analyzer.Finding

	for _, dep := range deps {
		meta, mErr := client.GetPackageMetadata(ctx, dep.Name)
		if mErr != nil {
			continue
		}
		ver, ok := meta.Versions[dep.Version]
		if !ok {
			continue
		}
		for _, a := range analyzers {
			findings, aErr := a.Analyze(ctx, meta, &ver)
			if aErr != nil {
				continue
			}
			allFindings = append(allFindings, findings...)
		}
	}

	score := reputation.CalculateRiskScore(allFindings)

	return auditCompleteMsg{result: &AuditResult{
		PackageName: "node_modules: " + path,
		RiskScore:   score,
		Findings:    convertFindings(allFindings),
		Duration:    time.Since(start),
	}}
}

func runThreatUpdate(sourceURL string) tea.Msg {
	ctx := context.Background()
	err := reputation.UpdateThreatIntelligence(ctx, sourceURL)
	if err != nil {
		return threatErrorMsg{err: err}
	}
	return threatUpdateMsg{msg: "Threat intelligence updated from " + sourceURL}
}

func saveReport(result *AuditResult, path string) tea.Msg {
	if result == nil {
		return reportSaveErrorMsg{err: fmt.Errorf("no results to save")}
	}

	type reportJSON struct {
		Package   string    `json:"package"`
		RiskScore float64   `json:"risk_score"`
		Findings  []Finding `json:"findings"`
		Duration  string    `json:"duration"`
	}

	report := reportJSON{
		Package:   result.PackageName,
		RiskScore: result.RiskScore,
		Findings:  result.Findings,
		Duration:  result.Duration.String(),
	}

	data, err := json.MarshalIndent(report, "", "  ")
	if err != nil {
		return reportSaveErrorMsg{err: fmt.Errorf("marshaling report: %w", err)}
	}

	if err := os.WriteFile(path, data, 0644); err != nil {
		return reportSaveErrorMsg{err: fmt.Errorf("writing report to %s: %w", path, err)}
	}

	return reportSavedMsg{path: path}
}
```

## cmd/auditter/tui.go

```go
package main

import (
	"fmt"
	"os"

	tea "github.com/charmbracelet/bubbletea"

	"github.com/matiasbarram/npm-security-auditter/internal/tui"
)

func runTUI() error {
	m := tui.NewModel()
	p := tea.NewProgram(m, tea.WithAltScreen(), tea.WithMouseCellMotion())
	if _, err := p.Run(); err != nil {
		return fmt.Errorf("TUI error: %w", err)
	}
	return nil
}

func tuiCommand() {
	if err := runTUI(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
```

---

**Notes on integration:**

1. **Dependencies to add** — run:
   ```
   go get github.com/charmbracelet/bubbletea
   go get github.com/charmbracelet/bubbles
   go get github.com/charmbracelet/lipgloss
   ```

2. **Wire `tuiCommand()` into main.go** — add a `tui` subcommand to your CLI (e.g., in the cobra/urfave command setup):
   ```go
   // In your CLI setup:
   case "tui":
       tuiCommand()
   ```

3. **Adapter functions** — `commands.go` references `analyzer.DefaultAnalyzers()`, `analyzer.Finding`, `project.ParsePackageJSON()`, `project.ScanNodeModules()`, `reputation.CalculateRiskScore()`, and `reputation.UpdateThreatIntelligence()`. You'll need to adjust these to match your actual function signatures. The names are based on common patterns from your codebase; if they differ, update the imports and calls accordingly.

4. **File count** — I added `internal/tui/commands.go` as a 6th file since the audit execution logic deserves its own file rather than being stuffed into `update.go` or `model.go`. This keeps the Bubble Tea architecture clean (model/view/update separation) with commands handling side effects.
