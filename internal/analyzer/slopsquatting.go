package analyzer

import (
	"context"
	"fmt"
	"strings"

	"github.com/kluth/npm-security-auditter/internal/registry"
)

// SlopsquattingAnalyzer detects packages with names that appear to be
// LLM-hallucinated package suggestions. Attackers register packages with names
// that AI coding assistants commonly suggest but don't actually exist.
// See: https://blog.socket.dev/slopsquatting-how-ai-hallucinations-are-fueling-a-new-class-of-supply-chain-attacks
type SlopsquattingAnalyzer struct{}

func NewSlopsquattingAnalyzer() *SlopsquattingAnalyzer {
	return &SlopsquattingAnalyzer{}
}

func (a *SlopsquattingAnalyzer) Name() string {
	return "slopsquatting"
}

// llmSuffixes are common suffixes that LLMs attach to popular package names.
var llmSuffixes = []string{
	"-helper", "-helpers", "-utils", "-util", "-toolkit", "-tools",
	"-wrapper", "-wrappers", "-lib", "-library", "-module",
	"-plugin", "-extension", "-connector", "-adapter",
	"-client", "-sdk", "-api", "-service",
}

// llmPrefixes are common prefixes LLMs use to create package names.
var llmPrefixes = []string{
	"simple-", "easy-", "fast-", "quick-", "modern-",
	"node-", "js-", "npm-", "the-",
}

// llmGenericWords are words commonly used in LLM-hallucinated names.
var llmGenericWords = []string{
	"helper", "utils", "toolkit", "wrapper", "parser",
	"validator", "handler", "manager", "builder", "formatter",
	"converter", "transformer", "processor", "generator", "serializer",
	"authentication", "authorization", "middleware", "component",
}

// languageFrameworkWords that LLMs often incorrectly combine.
var languageFrameworkWords = []string{
	"python", "java", "ruby", "go", "rust", "php",
	"flask", "django", "spring", "rails",
	"angular", "react", "vue", "svelte", "next",
	"express", "fastify", "koa", "nest",
}

func (a *SlopsquattingAnalyzer) Analyze(ctx context.Context, pkg *registry.PackageMetadata, version *registry.PackageVersion) ([]Finding, error) {
	var findings []Finding
	name := pkg.Name

	// Check for popular package + LLM suffix pattern
	findings = append(findings, a.checkPopularPlusSuffix(name)...)

	// Check if name matches LLM-style hallucination patterns
	if isLLMStyleName(name) {
		findings = append(findings, Finding{
			Analyzer:    a.Name(),
			Title:       "Potential slopsquatting: LLM-style package name",
			Description: fmt.Sprintf("Package name %q matches patterns commonly generated by AI coding assistants (overly descriptive compound name).", name),
			Severity:    SeverityMedium,
			ExploitExample: "Slopsquatting exploits AI code generation:\n" +
				"    1. LLMs like ChatGPT/Copilot hallucinate package names that don't exist\n" +
				"    2. Attackers register these hallucinated names on npm\n" +
				"    3. Developers using AI-generated code install the malicious package\n" +
				"    4. The package contains a real malicious payload\n" +
				"    Study: 19.7% of AI-suggested npm packages don't exist (2024 research)",
			Remediation: "Verify this package exists on npmjs.com and has a legitimate maintainer. Cross-reference with AI suggestions carefully.",
		})
	}

	return findings, nil
}

// checkPopularPlusSuffix checks if the name is a popular package + common LLM suffix.
func (a *SlopsquattingAnalyzer) checkPopularPlusSuffix(name string) []Finding {
	var findings []Finding
	normalized := normalizeName(name)

	for _, popular := range popularPackages {
		popNorm := normalizeName(popular)
		if normalized == popNorm {
			continue // It IS the popular package
		}

		for _, suffix := range llmSuffixes {
			if normalized == popNorm+suffix {
				findings = append(findings, Finding{
					Analyzer:    a.Name(),
					Title:       fmt.Sprintf("Potential slopsquatting: popular package %q with suffix", popular),
					Description: fmt.Sprintf("Package %q looks like an AI-hallucinated variant of the popular package %q with suffix %q.", name, popular, suffix),
					Severity:    SeverityHigh,
					ExploitExample: fmt.Sprintf("LLMs frequently suggest %q when users ask about %q:\n", name, popular) +
						"    - AI coding assistants generate plausible but non-existent names\n" +
						"    - Attackers register these names before real developers do\n" +
						"    - The malicious package mimics the real package's API",
					Remediation: fmt.Sprintf("Use the well-known package %q directly instead of %q.", popular, name),
				})
				break
			}
		}
	}

	return findings
}

// isLLMStyleName checks if a package name matches patterns commonly
// generated by AI hallucinations.
func isLLMStyleName(name string) bool {
	parts := strings.Split(name, "-")

	// LLM-style names tend to be long compound names (3+ hyphenated parts)
	if len(parts) < 3 {
		return false
	}

	// Check for language-framework-utility pattern (very LLM-like)
	hasLanguageWord := false
	hasGenericWord := false
	for _, part := range parts {
		partLower := strings.ToLower(part)
		for _, lf := range languageFrameworkWords {
			if partLower == lf {
				hasLanguageWord = true
				break
			}
		}
		for _, gw := range llmGenericWords {
			if partLower == gw {
				hasGenericWord = true
				break
			}
		}
	}

	if hasLanguageWord && hasGenericWord {
		return true
	}

	// 4+ part names with generic words are very suspicious
	if len(parts) >= 4 && hasGenericWord {
		return true
	}

	// Check for prefix + popular + suffix pattern
	for _, prefix := range llmPrefixes {
		if strings.HasPrefix(name, prefix) {
			remainder := strings.TrimPrefix(name, prefix)
			for _, suffix := range llmSuffixes {
				if strings.HasSuffix(remainder, suffix) {
					return true
				}
			}
		}
	}

	return false
}
